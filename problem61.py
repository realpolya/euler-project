'''
Cyclical Figurate Numbers

Triangle, square, pentagonal, hexagonal, heptagonal, and octagonal numbers 
are all figurate (polygonal) numbers and are generated by the following formulae:


Triangle
P_{3,n}=n(n+1)/2
1, 3, 6, 10, 15, ...


Square
P_{4,n}=n^2
1, 4, 9, 16, 25, ...


Pentagonal
P_{5,n}=n(3n-1)/2
1, 5, 12, 22, 35, ...


Hexagonal
P_{6,n}=n(2n-1)
1, 6, 15, 28, 45, ...


Heptagonal
P_{7,n}=n(5n-3)/2
1, 7, 18, 34, 55, ...


Octagonal
P_{8,n}=n(3n-2)
1, 8, 21, 40, 65, ...

The ordered set of three 4-digit numbers: 8128, 2882, 8281, has three 
interesting properties.

- The set is cyclic, in that the last two digits of each number is 
the first two digits of the next number (including the last number with the first).
- Each polygonal type: triangle (P_{3,127}=8128), square (P_{4,91}=8281), 
and pentagonal (P_{5,44}=2882), is represented by a different number in the set.
- This is the only set of 4-digit numbers with this property.

Find the sum of the only ordered set of six cyclic 4-digit numbers for 
which each polygonal type: triangle, square, pentagonal, hexagonal, heptagonal, 
and octagonal, is represented by a different number in the set.

'''

# find 6 numbers (all 4 digits) â€“ not nessecarily ascending or descending order
# find all of the numbers up between 1000 and 10 000 in each set

from extras.utils import generate_polygonal_set

def triangular_formula(n):
    return n * (n+1) / 2

def square_formula(n):
    return n ** 2

def pentagonal_formula(n):
    return n * (3 * n - 1)/2

def hexagonal_formula(n):
    return n * (2 * n - 1)

def heptagonal_formula(n):
    return n * (5 * n - 3) / 2

def octagonal_formula(n):
    return n * (3 * n - 2)

def find_overlap(chars, set):
    '''chars are y, checks for numbers that are yr'''

    overlapping = []

    for num in set:

        first_two = str(num)[:2]

        if first_two == chars:
            overlapping.append(num)
    
    return overlapping


def find_cyclical_sum():

    start = 1000
    limit = 10000

    rk_values = generate_polygonal_set(start, limit, triangular_formula) # rk is in triangular numbers

    square_set = generate_polygonal_set(start, limit, square_formula)
    penta_set = generate_polygonal_set(start, limit, pentagonal_formula)
    hexa_set = generate_polygonal_set(start, limit, hexagonal_formula)
    hepta_set = generate_polygonal_set(start, limit, heptagonal_formula)
    octa_set = generate_polygonal_set(start, limit, octagonal_formula)

    all_sets = {
        'tri': rk_values, 
        'squ': square_set, 
        'pen': penta_set, 
        'hex': hexa_set, 
        'hep': hepta_set, 
        'oct': octa_set
    }


    def find_kl(rk, all_sets):
        '''finding first kl set beyond "tri"'''

        kl_possibilities = {}

        for key, other_set in all_sets.items():

            if key != "tri":

                kl_possibilities[key] = set()

                r = str(rk)[:2]
                k = str(rk)[-2:]

                plausible = find_overlap(k, other_set) # kl

                if plausible:
                    kl_possibilities[key].update(plausible)
        
        return kl_possibilities


    def find_ab(suspect, all_sets, possibilities, removed=[]):
        '''general function to start exploring the tree'''

        ab_possibilities = {}

        for key, other_set in all_sets.items():

            if key != "tri" and key not in removed:

                    ab_possibilities[key] = set()

                    if suspect in possibilities.keys():

                        for za in possibilities[suspect]:

                            z = str(za)[:2]
                            a = str(za)[-2:]

                            plausible = find_overlap(a, other_set) # ab

                            if plausible:
                                ab_possibilities[key].update(plausible)
        
        ab_possibilities = {k: v for k, v in ab_possibilities.items() if v}
        
        return ab_possibilities


    suspect_list = ["squ", "pen", "hex", "hep", "oct"]


    for rk in rk_values:

        r = str(rk)[:2]
        k = str(rk)[-2:]

        kl_possibilities = find_kl(rk, all_sets)
        
        for suspect_1 in suspect_list:

            removed_suspects = [suspect_1]

            lm_possibilities = find_ab(suspect_1, all_sets, kl_possibilities, removed_suspects)
            
            for suspect_2 in suspect_list:

                if suspect_2 == suspect_1 or not lm_possibilities:
                    continue
                
                removed_suspects = [suspect_1, suspect_2]
                mx_possibilities = find_ab(suspect_2, all_sets, lm_possibilities, removed_suspects)

                for suspect_3 in suspect_list:

                    if suspect_3 == suspect_1 or suspect_3 == suspect_2 or not mx_possibilities:
                        continue

                    removed_suspects = [suspect_1, suspect_2, suspect_3]
                    xy_possibilities = find_ab(suspect_3, all_sets, mx_possibilities, removed_suspects)

                    for suspect_4 in suspect_list:

                        if suspect_4 == suspect_1 or suspect_4 == suspect_2 or suspect_4 == suspect_3 or not xy_possibilities:
                            continue
                        
                        removed_suspects = [suspect_1, suspect_2, suspect_3, suspect_4]
                        yr_possibilities = find_ab(suspect_4, all_sets, xy_possibilities, removed_suspects)
                        if yr_possibilities:
                        
                            for yr_key, yr_set in yr_possibilities.items():

                                for yr in yr_set:

                                    if r == str(yr)[-2:]:

                                        # print("match found, rk is ", rk, "yr is ", yr, "in set", yr_key, "")
                                        # print("yr possibilities are ", yr_possibilities)
                                        # print("xy possibilities are ", xy_possibilities)
                                        # print("mx possibilities are ", mx_possibilities)
                                        # print("lm possibilities are ", lm_possibilities)
                                        # print("kl possibilities are ", kl_possibilities)

                                        win_rk = rk
                                        wins = [
                                            yr_possibilities.copy(), 
                                            xy_possibilities.copy(), 
                                            mx_possibilities.copy(),
                                            lm_possibilities.copy(),
                                            kl_possibilities.copy()
                                        ]
    
    final_sum = win_rk
    n = str(win_rk)[:2]

    def add_to_sum(win_set, char):
        to_add = 0
        for key, value_set in win_set.items():
            for ab in value_set:
                if str(ab)[-2:] == char:
                    to_add = ab
        return to_add

    for win_set in wins:
        to_add = add_to_sum(win_set, n)
        final_sum += to_add
        n = str(to_add)[:2]


    return final_sum
    

print("Answer to problem 61: ", find_cyclical_sum())