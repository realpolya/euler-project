'''
Cyclical Figurate Numbers

Triangle, square, pentagonal, hexagonal, heptagonal, and octagonal numbers 
are all figurate (polygonal) numbers and are generated by the following formulae:


Triangle
P_{3,n}=n(n+1)/2
1, 3, 6, 10, 15, ...


Square
P_{4,n}=n^2
1, 4, 9, 16, 25, ...


Pentagonal
P_{5,n}=n(3n-1)/2
1, 5, 12, 22, 35, ...


Hexagonal
P_{6,n}=n(2n-1)
1, 6, 15, 28, 45, ...


Heptagonal
P_{7,n}=n(5n-3)/2
1, 7, 18, 34, 55, ...


Octagonal
P_{8,n}=n(3n-2)
1, 8, 21, 40, 65, ...

The ordered set of three 4-digit numbers: 8128, 2882, 8281, has three 
interesting properties.

- The set is cyclic, in that the last two digits of each number is 
the first two digits of the next number (including the last number with the first).
- Each polygonal type: triangle (P_{3,127}=8128), square (P_{4,91}=8281), 
and pentagonal (P_{5,44}=2882), is represented by a different number in the set.
- This is the only set of 4-digit numbers with this property.

Find the sum of the only ordered set of six cyclic 4-digit numbers for 
which each polygonal type: triangle, square, pentagonal, hexagonal, heptagonal, 
and octagonal, is represented by a different number in the set.

'''

# find 6 numbers (all 4 digits) â€“ not nessecarily ascending or descending order

# find all of the numbers up between 1000 and 10 000 in each set

from extras.utils import generate_polygonal_set

def triangular_formula(n):
    return n * (n+1) / 2

def square_formula(n):
    return n ** 2

def pentagonal_formula(n):
    return n * (3 * n - 1)/2

def hexagonal_formula(n):
    return n * (2 * n - 1)

def heptagonal_formula(n):
    return n * (5 * n - 3) / 2

def octagonal_formula(n):
    return n * (3 * n - 2)


def find_overlap(chars, set, direction):

    overlapping = []

    for num in set:

        first_two = str(num)[:2]
        last_two = str(num)[-2:]

        if direction == "last" and last_two == chars:
            overlapping.append(num)
        elif direction == "first" and first_two == chars:
            overlapping.append(num)
    
    return overlapping


def generate_sets():

    start = 1000
    limit = 10000

    tri_set = generate_polygonal_set(start, limit, triangular_formula)
    square_set = generate_polygonal_set(start, limit, square_formula)
    penta_set = generate_polygonal_set(start, limit, pentagonal_formula)
    hexa_set = generate_polygonal_set(start, limit, hexagonal_formula)
    hepta_set = generate_polygonal_set(start, limit, heptagonal_formula)
    octa_set = generate_polygonal_set(start, limit, octagonal_formula)

    list_of_sets = [square_set, penta_set, hexa_set, hepta_set, octa_set]

    tri_dict_kl = {}
    tri_dict_yr = {}
    lm_dict = {}
    xy_dict = {}

    for tri in tri_set:

        r = str(tri)[:2]
        k = str(tri)[-2:]

        plausible_kl = set()
        plausible_yr = set()
        set_num = 4

        for other_set in list_of_sets:

            plausible_first = find_overlap(r, other_set, "last") # yr
            plausible_last = find_overlap(k, other_set, "first") # kl

            if plausible_first:
                plausible_yr.update(plausible_first)
            if plausible_last:
                plausible_kl.update(plausible_last)

            # print("for set ", set_num, "the first overlap is ", plausible_first, "and the last overlap is ", plausible_last)

            # plausible_members.update()

            set_num += 1
        
        if plausible_kl:
            tri_dict_kl[str(tri)] = plausible_kl
        if plausible_yr:
            tri_dict_yr[str(tri)] = plausible_yr
        
        # print("for num ", tri, "plausible kl are ", plausible_kl, "and plausible yr are ", plausible_yr)
    
    # print(tri_dict_kl)
    # print(tri_dict_yr)

    for key, value in tri_dict_kl.items():

        for kl in value:

            k = str(kl)[:2]
            l = str(kl)[-2:]

            plausible_lm = set()

            for other_set in list_of_sets:

                plausible_last = find_overlap(l, other_set, "first") # lm

                if plausible_last:
                    plausible_lm.update(plausible_last)

                set_num += 1
            
            if plausible_lm:
                lm_dict[str(kl)] = plausible_lm
    
    print("lm dict is ", lm_dict)

    for key, value in tri_dict_yr.items():

        for yr in value:

            y = str(kl)[:2]
            r = str(kl)[-2:]

            plausible_xy = set()

            for other_set in list_of_sets:

                plausible_first = find_overlap(y, other_set, "last") # xy

                if plausible_first:
                    plausible_xy.update(plausible_first)

                set_num += 1
            
            if plausible_xy:
                xy_dict[str(yr)] = plausible_xy
    
    print("xy dict is ", lm_dict)







generate_sets()